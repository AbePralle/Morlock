uses Utility/Best

try
  forEach (type in TypeInfo.iterator)
    if (type.instance_of(<<Package>>) and type is not <<Package>>)
      local package = type.create_object<<Package>>
      package.init( System.command_line_arguments.cloned )
      package.handle_action
    endIf
  endForEach

catch (err:PackageError)
  Console.error.println err
  System.exit 1

endTry

class Package
  PROPERTIES
    action            : String
    name              : String
    provider          : String
    app_name          : String
    specified_version : String
    version           : String
    url               : String
    morlock_home      : String
    launcher_folder   : String
    install_folder    : String
    bin_folder        : String
    archive_filename  : String
    archive_folder    : String
    is_unpacked       : String

    releases         = @[]
    properties       : Value

  METHODS
    method init( args:String[] )
      require args.count
      properties = JSON.parse( args.first )

      if (not name or name.count('/')>1)
        throw PackageError(
          File.filename(properties//script_filepath),
          ''Package name must be specified as a property. For example:\n\n  PROPERTIES\n    name = "provider/$"''...
          (File.filename(properties//script_filepath).before_last('.'))
        )
      endIf

      if (not name.contains('/')) name = name/name

      provider = name.before_first('/')
      app_name = name.after_first('/')

      action = properties//action
      morlock_home = properties//morlock_home
      launcher_folder = morlock_home/"bin"

      init
      if (properties//version)
        specified_version = properties//version
        version = specified_version
      endIf
      select_version
      install_folder = "$/$" (properties//package_folder,version)
      bin_folder = install_folder/"bin"

    method init
      noAction

    method build
      # Attempts to automatically figure out how build the downloaded & unpacked
      # archive and launches the appropriate commands.
      forEach (folder in File.listing(".",&folders))
        if (File.exists(folder/"Build.rogue"))
          execute "cd $ && rogo build" (folder)
          archive_folder = folder
          return
        endIf
      endForEach

      if (not is_unpacked)
        # Most likely the script just didn't call unpack() yet.
        unpack
        is_unpacked = true
        build
      else
        throw error( "Unable to determine how to build $ after unpacking it."(url) )
      endIf

    method copy_executable( src_filepath:String, dest_filename=null:String )
      if (not dest_filename) dest_filename = app_name
      local dest_filepath = bin_folder/dest_filename

      println "Copying $ -> $" (src_filepath,dest_filepath)
      File.copy( src_filepath, dest_filepath )
      execute( "chmod u+x $" (File.esc(dest_filepath)), &bg )

    method create_folder( folder:String )
      println "  " + folder
      File.create_folder( folder )
      if (not File.is_folder(folder))
        throw error( ''Error creating folder "$".''(folder) )
      endIf

    method download->String
      execute( "curl -LfsSO " + url, &bg )
      archive_filename = File.filename(url)
      if (not File.exists(archive_filename)) throw error( "Error downloading " + url )
      return archive_filename

    method error( message:String )->Error
      return PackageError( provider/app_name, message )

    method execute( cmd:String, &bg )
      if (not bg )println "> " + cmd
      if (0 != System.run(cmd))
        throw error( "Error executing:\n"+cmd )
      endIf

    method handle_action
      which (action)
        case "install"
          handle_install
        case "uninstall"
          if (File.exists(install_folder))
            header "Uninstalling $ version $"(name,version)
            File.delete( install_folder )
          elseIf (specified_version)
            throw error( "$ version $ is not installed." (name,version) )
          else
            throw error( "$ is not installed." (name) )
          endIf
        others
          println ''WARNING: morlock script $.rogue does not support action "$".''(app_name,action)
      endWhich

    method header( message:String )
      println "-" * Console.width.or_smaller(80)
      println message
      println "-" * Console.width.or_smaller(80)

    method handle_install
      if (File.exists(install_folder))
        throw error( "$ version $ is already installed."(name,version) )
      endIf

      try
        println "-" * Console.width.or_smaller(80)
        println "Installing $ v$" (app_name,version)
        println "-" * Console.width.or_smaller(80)
        println "Creating install folder"
        create_folder( install_folder )
        create_folder( bin_folder )
        install
      catch (err:Error)
        File.delete( install_folder )
        throw err
      endTry

    method install
      throw error( "install() must overridden." )

    method install_products( default=null:String, windows=null:String, macos=null:String, linux=null:String, &link=true )
      local pattern : String
      if (System.is_macos)       pattern = which{ macos || default }
      elseIf (System.is_linux)   pattern = which{ linux || default }
      elseIf (System.is_windows) pattern = which{ windows || default }
      else                       pattern = default

      if (not pattern) throw error( "No filepath or pattern given for $."(System.os) )

      pattern = pattern.replacing( "$(OS)", System.os )

      local exe_list = File.listing( archive_folder/pattern )
      if (exe_list.is_empty) throw error( "Cannot locate build product." )
      copy_executable( forEach in exe_list )
      if (link) this.link

    method link
      local exe_list = File.listing( bin_folder/"*" )
      forEach (exe in exe_list)
        local launcher = launcher_folder/File.filename(exe)
        File.delete( launcher )
        local cmd = "ln -s $ $" (exe,launcher)
        execute( cmd, &bg )
      endForEach

    method release( url:String, platforms=null:String, version=null:String )
      # Registers a release with .tar.gz/.zip URL and version number.
      #
      # platforms
      #   Any combination of characters w, m, l (windows, mac, linux)
      #   If unspecified then .tar.gz implies "ml" and any other extension
      #   implies "wml". Mac and Linux will prefer .tar.gz over other extensions
      #   if multiple possibilities are given.
      #
      # version
      #   In the format "1", "1.0", "1.0.0", etc. Will be inferred from url
      #   if unspecified.
      if (not platforms)
        local lc = url.to_lowercase
        platforms = which { lc.ends_with(".tar.gz"):"ml" || "wml" }
      endIf

      if (not version)
        local lc = url.to_lowercase
        local span = lc.locate_pattern("v$(I)")
        contingent
          sufficient (span.exists)
          span = lc.locate_pattern("$(I).(I)")
          sufficient (span.exists)
          span = lc.locate_pattern("$(I)?(I)")
          sufficient (span.exists)
          span = lc.locate_pattern("$(I)")
          sufficient (span.exists)
          throw error( 'Cannot determine version number from release URL "$".'(url) )
        endContingent
        version = url.substring( span.value.index )
        local separator_index = span.value.index + span.value.count
        local separator = which{ (separator_index<url.count):url[separator_index] || '.' }
        use builder = StringBuilder.pool
          local found_numbers = false
          forEach (ch in version)
            if (ch == separator) builder.print "."
            elseIf (ch.is_number) builder.print ch; found_numbers = true
            elseIf (found_numbers) escapeForEach
          endForEach
          version = builder->String.without_trailing('.')
        endUse
      endIf

      releases.add @{ :version, :url, :platforms }

    method select_version
      if (releases.is_empty) throw error( "No releases are available." )

      local platform = which{ System.is_windows:'w' || System.is_macos:'m' || 'l' }

      if (String.exists(version))
        local best = Best<<String>>( (a,b) => VersionNumber(a) > b )
        forEach (release in releases)
          local v = release//version->String
          if (VersionNumber(version).is_compatible_with(v)) best.consider( v )
        endForEach
        if (not best.exists)
          use builder = StringBuilder.pool
            builder.println "No release is compatible with requested version '$'. Available versions:" (version)
            local compatible = @{}
            forEach (release in releases)
              if (release//platforms->String.contains(platform))
                compatible[ release//version ] = release//version
              endIf
            endForEach
            block compatible = compatible.to_list<<String>>.[ sort( (a,b) => VersionNumber(a) > b ) ]
              builder.println "  " + (forEach in compatible)
            endBlock
            throw error( builder )
          endUse
        endIf
        version = best.value

      else
        local best = Best<<String>>( (a,b) => VersionNumber(a) > b )
        forEach (release in releases)
          local v = release//version->String
          best.consider( v )
        endForEach
        version = best.value

      endIf

      # Now pick the best URL with the given version number
      url = null
      forEach (release in releases)
        if (VersionNumber(release//version) == version and release//platforms->String.contains(platform))
          url = release//url
          if (not System.is_windows and url.ends_with(".tar.gz",&ignore_case)) escapeForEach
        endIf
      endForEach

    method uninstall

    method unpack
      if (not archive_filename or not File.exists(archive_filename))
        download
      endIf
      if (archive_filename.ends_with(".zip",&ignore_case))
        throw error( "TODO: unpack ZIP." )
      elseIf (archive_filename.ends_with(".tar.gz"))
        execute "tar -xvf " + archive_filename
        is_unpacked = true
      else
        throw error( "Cannot unpack() file type '.$'; write custom install() code to handle it." )
      endIf
endClass

class PackageError( package_name:String, message ) : Error
  METHODS
    method description->String
      use builder = StringBuilder.pool
        local w = message.longest_line.or_larger(80).or_smaller( Console.width )
        local hr = "=" * w
        builder.println hr
        builder.println "ERROR [$]\n" (package_name)
        builder.println message
        builder.println hr
        return builder
      endUse
endClass

