uses Utility/Best

try
  forEach (type in TypeInfo.iterator)
    if (type.instance_of(<<Package>>) and type is not <<Package>>)
      local package = type.create_object<<Package>>
      package.init( System.command_line_arguments.cloned )
      package.handle_action
    endIf
  endForEach

catch (err:PackageError)
  Console.error.println err
  System.exit 1

endTry

class Package
  PROPERTIES
    action           : String
    provider         : String
    app_name         : String
    version          : String
    url              : String
    morlock_home     : String
    launcher_folder  : String
    install_folder   : String
    bin_folder       : String
    archive_filename : String
    archive_folder   : String
    is_unpacked      : String

    releases         = @[]
    properties       : Value

  METHODS
    method init( args:String[] )
      require args.count
      properties = JSON.parse( args.first )
      action = properties//action
      provider = properties//provider
      app_name = properties//app_name
      morlock_home = properties//morlock_home
      launcher_folder = morlock_home/"bin"

      init
      if (properties//version) version = properties//version
      select_version
      install_folder = "$/$" (properties//package_folder,version)
      bin_folder = install_folder/"bin"

    method init
      noAction

    method build
      # Attempts to automatically figure out how build the downloaded & unpacked
      # archive and launches the appropriate commands.
      forEach (folder in File.listing(".",&folders))
        if (File.exists(folder/"Build.rogue"))
          execute "cd $ && rogo build" (folder)
          archive_folder = folder
          return
        endIf
      endForEach

      if (not is_unpacked)
        # Most likely the script just didn't call unpack() yet.
        unpack
        is_unpacked = true
        build
      else
        throw error( "Unable to determine how to build $ after unpacking it."(url) )
      endIf

    method copy_executable( src_filepath:String, dest_filename=null:String )
      if (not dest_filename) dest_filename = app_name
      local dest_filepath = bin_folder/dest_filename

      println "Copying $ -> $" (src_filepath,dest_filepath)
      File.copy( src_filepath, dest_filepath )
      execute( "chmod u+x $" (File.esc(dest_filepath)) )

    method create_folder( folder:String )
      println "  " + folder
      File.create_folder( folder )
      if (not File.is_folder(folder))
        throw error( ''Error creating folder "$".''(folder) )
      endIf

    method download->String
      execute "curl -LfsSO " + url
      archive_filename = File.filename(url)
      if (not File.exists(archive_filename)) throw error( "Error downloading " + url )
      return archive_filename

    method error( message:String )->Error
      return PackageError( provider, app_name, message )

    method execute( cmd:String )
      println "> " + cmd
      if (0 != System.run(cmd))
        throw error( "Error executing:\n"+cmd )
      endIf

    method handle_action
      which (action)
        case "install"
          handle_install
        others
          println ''WARNING: morlock script $.rogue does not support action "$".''(app_name,action)
      endWhich

    method handle_install
      println "-" * Console.width.or_smaller(80)
      println "Installing $ v$" (app_name,version)
      println "-" * Console.width.or_smaller(80)
      println "Creating install folder"
      create_folder( install_folder )
      create_folder( bin_folder )
      install

    method install
      throw error( "install() must overridden." )

    method link
      local exe_list = File.listing( bin_folder/"*" )
      forEach (exe in exe_list)
        local launcher = launcher_folder/File.filename(exe)
        if (not File.exists(launcher))
          local cmd = "ln -s $ $" (exe,launcher)
          execute cmd
        endIf
      endForEach

    method release( url:String, platforms=null:String, version=null:String )
      # Registers a release with .tar.gz/.zip URL and version number.
      #
      # platforms
      #   Any combination of characters w, m, l (windows, mac, linux)
      #   If unspecified then .tar.gz implies "ml" and any other extension
      #   implies "wml". Mac and Linux will prefer .tar.gz over other extensions
      #   if multiple possibilities are given.
      #
      # version
      #   In the format "1", "1.0", "1.0.0", etc. Will be inferred from url
      #   if unspecified.
      if (not platforms)
        local lc = url.to_lowercase
        platforms = which { lc.ends_with(".tar.gz"):"ml" || "wml" }
      endIf

      if (not version)
        local lc = url.to_lowercase
        local span = lc.locate_pattern("v$(I)")
        contingent
          sufficient (span.exists)
          span = lc.locate_pattern("$(I).(I)")
          sufficient (span.exists)
          span = lc.locate_pattern("$(I)?(I)")
          sufficient (span.exists)
          span = lc.locate_pattern("$(I)")
          sufficient (span.exists)
          throw error( 'Cannot determine version number from release URL "$".'(url) )
        endContingent
        version = url.substring( span.value.index )
        local separator_index = span.value.index + span.value.count
        local separator = which{ (separator_index<url.count):url[separator_index] || '.' }
        use builder = StringBuilder.pool
          local found_numbers = false
          forEach (ch in version)
            if (ch == separator) builder.print "."
            elseIf (ch.is_number) builder.print ch; found_numbers = true
            elseIf (found_numbers) escapeForEach
          endForEach
          version = builder->String.without_trailing('.')
        endUse
      endIf

      releases.add @{ :version, :url, :platforms }

    method select_version
      if (releases.is_empty) throw error( "No releases are available." )

      local platform = which{ System.is_windows:'w' || System.is_macos:'m' || 'l' }

      if (String.exists(version))
        local best = Best<<String>>( (a,b) => VersionNumber(a) > b )
        forEach (release in releases)
          local v = release//version->String
          if (VersionNumber(version).is_compatible_with(v)) best.consider( v )
        endForEach
        if (not best.exists)
          use builder = StringBuilder.pool
            builder.println "No release is compatible with requested version '$'. Available versions:" (version)
            local compatible = @{}
            forEach (release in releases)
              if (release//platforms->String.contains(platform))
                compatible[ release//version ] = release//version
              endIf
            endForEach
            block compatible = compatible.to_list<<String>>.sort( (a,b) => VersionNumber(a) > b )
              builder.println "  " + (forEach in compatible)
            endBlock
            throw error( builder )
          endUse
        endIf
        version = best.value

      else
        local best = Best<<String>>( (a,b) => VersionNumber(a) > b )
        forEach (release in releases)
          local v = release//version->String
          best.consider( v )
        endForEach
        version = best.value

      endIf

      # Now pick the best URL with the given version number
      url = null
      forEach (release in releases)
        if (VersionNumber(release//version) == version and release//platforms->String.contains(platform))
          url = release//url
          if (not System.is_windows and url.ends_with(".tar.gz",&ignore_case)) escapeForEach
        endIf
      endForEach

    method uninstall

    method unpack
      if (not archive_filename or not File.exists(archive_filename))
        download
      endIf
      if (archive_filename.ends_with(".zip",&ignore_case))
        throw error( "TODO: unpack ZIP." )
      elseIf (archive_filename.ends_with(".tar.gz"))
        execute "tar -xvf " + archive_filename
        is_unpacked = true
      else
        throw error( "Cannot unpack() file type '.$'; write custom install() code to handle it." )
      endIf
endClass

class PackageError( provider:String, app_name:String, message ) : Error
  METHODS
    method description->String
      use builder = StringBuilder.pool
        local w = message.longest_line.or_larger(80).or_smaller( Console.width )
        local hr = "=" * w
        builder.println hr
        builder.println "ERROR [$/$]\n" (provider,app_name)
        builder.println message
        builder.println hr
        return builder
      endUse
endClass

