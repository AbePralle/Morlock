#================================================================================
# Morlock.rogue
# August 15, 2021
#================================================================================

$requireRogue "1.8.8"

uses Utility/CommandLineParser

$include "PackageInfo.rogue"

try
  Morlock( System.command_line_arguments )
catch (error:Error)
  local mesg = error->String
  local w = mesg.longest_line.or_larger(80).or_smaller( Console.width )
  Console.error.println "="*w
  Console.error.println "ERROR"
  Console.error.println mesg
  Console.error.println "="*w
  System.exit 1
endTry

class Morlock
  DEFINITIONS
    HOME = "/opt/morlock"

  METHODS
    method init( args:String[] )
      local command = parse_args( args )
      # 'command' has //options and possibly //args

      if (command//options//help or not command//action or command//action == "help")
        print_usage
        System.exit 0
      endIf

      configure_morlock

      which (command//action)
        case "install"
          local info = resolve_package( command//args.first, &allow_local_script )
          if (info.version and info.installed_versions.contains(info.version))
            throw error( "$ version $ is already installed."(info.name,info.version) )
          endIf
          info.fetch_latest_script
          run_script( "install", info )

        case "reinstall"
          local info = resolve_package( command//args.first, &allow_local_script )
          if (info.installed_versions.count)
            run_script( "uninstall", info )
          endIf
          info.fetch_latest_script
          run_script( "install", info )

        case "shellenv"
          local morlock_bin = HOME/"bin"
          if (not System.environment//PATH.contains(morlock_bin))
            print   ''export PATH="$'' (morlock_bin)
            println ''${PATH+:$PATH}";''
          endIf

        case "uninstall"
          local info = resolve_package( command//args.first )
          if (info.version and not info.installed_versions.contains(info.version))
            throw error( "$ version $ is not installed."(info.name,info.version) )
          endIf
          if (not File.exists(info.folder))
            throw error( "$ is not installed."(info.name) )
          endIf
          run_script( "uninstall", info )

        others
          throw error( "Unrecognized morlock command '$'."(command//action) )
      endWhich

    method configure_morlock
      create_folder( HOME, &chown )
      create_folder( HOME/"bin" )
      create_folder( HOME/"build" )
      create_folder( HOME/"packages" )

    method create_build_folder( info:PackageInfo )->String
      local build_folder = "$/$/$/$" (HOME,"build",info.provider,info.app_name)
      if (not File.is_folder(build_folder))
        println "Creating " + build_folder
        File.delete( build_folder )
        File.create_folder( build_folder )
      endIf
      return build_folder

    method create_folder( folder:String, &chown )
      if (not File.exists(folder))
        execute( "mkdir -p "+folder, &allow_sudo )

        if (chown)
          local user = System.environment//USER
          execute( "chown $ $" (user,folder), &allow_sudo )
        endIf
      endIf

    method error( message:String )->Error
      return Error( message )

    method header( message:String )
      println "-" * Console.width.or_smaller(80)
      println message
      println "-" * Console.width.or_smaller(80)

    method run_script( action:String, info:PackageInfo )
      local build_folder : String
      if (action == "install")
        build_folder = create_build_folder(info)
      endIf

      local script_args = @{ :action, provider:info.provider, app_name:info.app_name, version:info.version,
                             package_folder:info.folder, morlock_home:HOME }

      try
        block script_args = script_args.to_json.to_escaped_ascii('"')
          local exe_filepath = info.folder/info.app_name
          local crc32_filepath = info.folder/"source_crc32.txt"
          local crc32 : Int32
          contingent
            # Recompile?
            crc32 = File.crc32(info.filepath) ~ File.crc32("Source/Package.rogue")
            necessary (File.exists(exe_filepath))
            necessary (File.exists(crc32_filepath))
            necessary (crc32->String == String(File(crc32_filepath)).trimmed)

          unsatisfied
            build_folder = create_build_folder(info)
            local cmd = "roguec $ Source/Package.rogue --essential --api --compile --output=$/$" ...
                (info.filepath,File.esc(build_folder),info.app_name)
            execute cmd
            File.delete( exe_filepath )
            File.copy( build_folder/info.app_name, exe_filepath, &verbose )
            execute( "chmod u+x $" (File.esc(exe_filepath)) )
            File.save( crc32_filepath, crc32->String )

          endContingent

          if (action == "install")
            execute 'cd $ && $ "$"' (File.esc(build_folder),File.esc(exe_filepath),script_args)
          else
            execute 'cd $ && $ "$"' (File.esc(info.folder),File.esc(exe_filepath),script_args)
          endIf
        endBlock
      catch (err:Error)
        if (build_folder) File.delete( build_folder )
        System.exit 1
      endTry

    method resolve_package( name:String, &allow_local_script )->PackageInfo
      local info    : PackageInfo
      local version : String

      if (name.contains('@'))
        version = name.after_last('@')
        name .= before_last('@')
      endIf

      if (name.contains("://"))
        info = PackageInfo( name )

      elseIf (File.exists(name))
        # Local script for install.
        local filepath = name
        contingent
          sufficient (not File.is_folder(filepath))

          filepath = "$/$.rogue" (name,File.filename(name))
          sufficient (File.exists(filepath))

          local listing = File.listing( name/"*.rogue", &omit_path )
          if (listing.count == 1)
            filepath = name/listing.first
            sufficient (true)
          endIf

          if (listing.is_empty)
            throw error( "No morlock .rogue scripts exist in folder $"(name) )
          else
            throw error( "Multiple morlock .rogue scripts exist in folder $"(name) )
          endIf

        satisfied
          if (not allow_local_script)
            throw error( "A local .rogue script can only be used with 'morlock install'." )
          endIf

          if (filepath.contains('/'))
            local provider = File.filename( File.folder(filepath) )
            local app_name = File.filename( filepath ).before_last('.')
            info = PackageInfo( provider/app_name )
          else
            local app_name = filepath.before_last('.')
            info = PackageInfo( app_name/app_name )
          endIf
          info.using_local_script = true

          # Copy script into place
          File.create_folder( info.folder )
          File.copy( filepath, info.filepath, &if_different, &verbose )
        endContingent

      else
        # TODO: map 'name' to any "built-in" packages.
        if (name.contains('/'))
          info = PackageInfo( name )
        else
          local listing = File.listing( HOME/"packages/*/$"(name), &folders )
          which (listing.count)
            case 0
              info = PackageInfo( name )
            case 1
              local provider = File.filename(File.folder(listing.first))
              info = PackageInfo( provider/name )
            others
              use builder = StringBuilder.pool
                builder.println "Ambiguous app name '$' matches mulitple installed packages:"(name)
                builder.println "  $/$"(File.filename(File.folder(forEach in listing)),name)
                throw error( builder )
              endUse
          endWhich
        endIf

      endIf

      info.version = version

      return info

    method parse_args( args:String[] )->Value
      local command = CommandLineParser().
      [
        option( "--help", &aliases=["-h","-?"] )
      ].parse( args )

      if (command//args.count)
        command//action = command//args.remove_at(0)
        local argc = command//args.count
        which (command//action)
          case "install", "uninstall", "reinstall"
            if (argc != 1)
              throw error( "'morlock $' requires a single package name as argument."(command//action) )
            endIf
          case "shellenv"
            if (argc)
              throw error( "'morlock $' does not accept arguments."(command//action) )
            endIf
        endWhich
      endIf

      return command

    method print_usage
      println @|USAGE
               |  morlock COMMAND
               |
               |PRIMARY COMMANDS
               |  help, --help, -h, -?
               |    Show this help text.
               |
               |  install provider/app_name
               |
               |  reinstall provider/app_name
               |
               |  uninstall provider/app_name
               |
               |SECONDARY COMMANDS
               |  shellenv
               |    Prints out the shell commands that should be executed by your shell configuration.
               |    For example, in ~/.zprofile: eval "$(/opt/morlock/bin/morlock shellenv)"
               |
endClass

routine execute( cmd:String, &suppress_error, &allow_sudo )->Logical
  println "> " + cmd
  if (0 == System.run(cmd)) return true

  if (allow_sudo)
    println "Error executing '$'; retrying with 'sudo'."(cmd)
    return execute( "sudo "+cmd, &=suppress_error )
  endIf

  if (suppress_error) return false
  throw Error( "Error executing:\n$"(cmd) )
endRoutine

